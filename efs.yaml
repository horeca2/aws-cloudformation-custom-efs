AWSTemplateFormatVersion: 2010-09-09
Parameters:
  # BackupPolicyStatus:
  #   Type: String
  #   Default: DISABLED 
  #   AllowedValues:
  #     - DISABLED
  #     - ENABLED 
  # Encrypted:
  #   Type: String
  #   Default: false 
  #   AllowedValues:
  #     - false
  #     - true    
  # PerformanceMode:
  #   Type: String
  #   Default: generalPurpose  
  #   AllowedValues:
  #     - generalPurpose
  #     - maxIO
  # ProvisionedThroughputInMibps:
  #   Type: String  # ????? BUG ? ?????!!!
  # ThroughputMode:
  #   Type: String
  #   Default: bursting  
  #   AllowedValues:
  #     - bursting
  #     - provisioned
  RestorePoint:
    Type: String
  Vpc:
    Type: AWS::EC2::VPC::Id  
  Subnet1:
    Type: AWS::EC2::Subnet::Id  


Conditions:
  IsEmpty: !Equals [!Ref RestorePoint, '']  
  IsRestore: !Not [!Condition IsEmpty]  
       
Resources:
  EmptyFileSystem:
    Type: AWS::EFS::FileSystem
    Condition: IsEmpty
    Properties:
      BackupPolicy:
        Status: DISABLED
      Encrypted: "false"
      PerformanceMode: generalPurpose
      ThroughputMode: bursting
  
  RecoveredFileSystem:
     Type: Custom::RecoveredFileSystem
     Properties: 
       ServiceToken: !GetAtt LambdaStartExecutionStepFunction.Arn
       BackupVaultName: Default
       RecoveryPoint: arn:aws:backup:eu-central-1:918404900336:recovery-point:8ce28d06-437d-4c1b-83fa-dc2e46e729fe
       BackupIAMRoleArn: arn:aws:iam::918404900336:role/service-role/StepFunctions-MyStateMachine-role-f184143f
       
  LambdaSecurityGroup:
    Type: 'AWS::EC2::SecurityGroup'
    Properties:
      GroupDescription: Allow none
      VpcId: !Ref Vpc

  LambdaRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole'
        - 'arn:aws:iam::aws:policy/AmazonElasticFileSystemClientReadWriteAccess'
   
  

  StateMachineRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - states.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/AWSBackupFullAccess'
        - 'arn:aws:iam::aws:policy/AmazonElasticFileSystemFullAccess'
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaRole'
      Policies:
        - PolicyDocument: |
            {
                "Version": "2012-10-17",
                "Statement": [
                    {
                        "Effect": "Allow",
                        "Action": [
                            "iam:GetRole",
                            "iam:PassRole"
                        ],
                        "Resource": "arn:aws:iam::*:role/*"
                    }
                ]
            }
          PolicyName: CustomEfsPolicy1

  StateMachine:
    Type: AWS::StepFunctions::StateMachine
    DependsOn: LambdaSendResponse
    Properties:
      DefinitionString: !Sub |
        {
          "Comment": "A description of my state machine",
          "StartAt": "Choice action",
          "States": {
            "Choice action": {
              "Type": "Choice",
              "Choices": [
                {
                  "Variable": "$.Request.RequestType",
                  "StringEquals": "Create",
                  "Next": "GetRecoveryPointRestoreMetadata"
                },
                {
                  "Variable": "$.Request.RequestType",
                  "StringEquals": "Delete",
                  "Next": "DeleteFileSystem"
                }
              ]
            },
            "GetRecoveryPointRestoreMetadata": {
              "Type": "Task",
              "Parameters": {
                "BackupVaultName.$": "$.Request.ResourceProperties.BackupVaultName",
                "RecoveryPointArn.$": "$.Request.ResourceProperties.RecoveryPoint"
              },
              "Resource": "arn:aws:states:::aws-sdk:backup:getRecoveryPointRestoreMetadata",
              "ResultPath": "$.GetRecoveryPointRestoreMetadataResult",
              "Next": "StartRestoreJob"
            },
            "StartRestoreJob": {
              "Type": "Task",
              "Parameters": {
                "IamRoleArn.$": "$.Request.ResourceProperties.BackupIAMRoleArn",
                "Metadata": {
                  "file-system-id.$": "$.GetRecoveryPointRestoreMetadataResult.RestoreMetadata.file-system-id",
                  "Encrypted": "false",
                  "PerformanceMode": "generalPurpose",
                  "CreationToken.$": "$.GetRecoveryPointRestoreMetadataResult.RestoreMetadata.aws:backup:request-id",
                  "newFileSystem": "true"
                },
                "RecoveryPointArn.$": "$.Request.ResourceProperties.RecoveryPoint",
                "ResourceType": "EFS"
              },
              "Resource": "arn:aws:states:::aws-sdk:backup:startRestoreJob",
              "ResultPath": "$.StartRestoreJobResult",
              "Next": "Wait for job completed"
            },
            "Wait for job completed": {
              "Type": "Wait",
              "Seconds": 30,
              "Next": "DescribeRestoreJob"
            },
            "DescribeRestoreJob": {
              "Type": "Task",
              "Parameters": {
                "RestoreJobId.$": "$.StartRestoreJobResult.RestoreJobId"
              },
              "Resource": "arn:aws:states:::aws-sdk:backup:describeRestoreJob",
              "ResultPath": "$.DescribeRestoreJobResult",
              "Next": "Restore Job Completed?"
            },
            "Restore Job Completed?": {
              "Type": "Choice",
              "Choices": [
                {
                  "Variable": "$.DescribeRestoreJobResult.Status",
                  "StringEquals": "COMPLETED",
                  "Next": "Transform arn to efs id"
                }
              ],
              "Default": "Wait for job completed"
            },
            "Transform arn to efs id": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Parameters": {
                "FunctionName": "${LambdaArnToEfsId}",
                "Payload": {
                  "Arn.$": "$.DescribeRestoreJobResult.CreatedResourceArn"
                }
              },
              "ResultPath": "$.TransformArnToEfsIdResult",
              "Retry": [
                {
                  "ErrorEquals": [
                    "Lambda.ServiceException",
                    "Lambda.AWSLambdaException",
                    "Lambda.SdkClientException"
                  ],
                  "IntervalSeconds": 2,
                  "MaxAttempts": 6,
                  "BackoffRate": 2
                }
              ],
              "Next": "Send success created response"
            },
            "Send success created response": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Parameters": {
                "FunctionName": "${LambdaSendResponse}",
                "Payload": {
                  "Request.$": "$.Request",
                  "ResponseStatus": "SUCCESS",
                  "PhysicalResourceId.$": "$.TransformArnToEfsIdResult.Payload.EfsId"
                }
              },
              "Retry": [
                {
                  "ErrorEquals": [
                    "Lambda.ServiceException",
                    "Lambda.AWSLambdaException",
                    "Lambda.SdkClientException"
                  ],
                  "IntervalSeconds": 2,
                  "MaxAttempts": 6,
                  "BackoffRate": 2
                }
              ],
              "End": true
            },
            "DeleteFileSystem": {
              "Type": "Task",
              "Parameters": {
                "FileSystemId.$": "$.Request.PhysicalResourceId"
              },
              "Resource": "arn:aws:states:::aws-sdk:efs:deleteFileSystem",
              "Next": "Send success deleted response",
              "ResultPath": "$.DeleteFileSystemResult"
            },
            "Send success deleted response": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Parameters": {
                "FunctionName": "${LambdaSendResponse}",
                "Payload": {
                  "Request.$": "$.Request",
                  "ResponseStatus": "SUCCESS",
                  "PhysicalResourceId.$": "$.Request.PhysicalResourceId"
                }
              },
              "Retry": [
                {
                  "ErrorEquals": [
                    "Lambda.ServiceException",
                    "Lambda.AWSLambdaException",
                    "Lambda.SdkClientException"
                  ],
                  "IntervalSeconds": 2,
                  "MaxAttempts": 6,
                  "BackoffRate": 2
                }
              ],
              "End": true
            }
          }
        } 
      # DefinitionSubstitutions:  
      RoleArn: !GetAtt StateMachineRole.Arn

  LambdaStartExecutionStepFunctionRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/AWSStepFunctionsFullAccess'

  LambdaStartExecutionStepFunction:
    Type: 'AWS::Lambda::Function' 
    Properties:
      Code:
        ZipFile: |
          exports.handler = async(event) => {
            const AWS = require('aws-sdk');
            const stepFunctions = new AWS.StepFunctions();
            const params = {
                stateMachineArn: process.env.StateMachineArn,
                input: JSON.stringify({Request: event}),
                name: event.RequestId
            };
            await stepFunctions.startExecution(params).promise();
          };
      Environment:
        Variables:
          StateMachineArn: !Ref StateMachine
      Role: !GetAtt LambdaStartExecutionStepFunctionRole.Arn
      Runtime: nodejs14.x
      Handler: index.handler
      Timeout: 30

  LambdaArnToEfsId:
    Type: 'AWS::Lambda::Function' 
    Properties:
      Code:
        ZipFile: |
          exports.handler = async (event) => {
            let match = event.Arn.match(/file-system\/(.+)/) || [];
            return {
              EfsId: match[1]
            };
          }
      Role: !GetAtt LambdaStartExecutionStepFunctionRole.Arn
      Runtime: nodejs14.x
      Handler: index.handler
      Timeout: 30

  LambdaSendResponse:
    Type: 'AWS::Lambda::Function' 
    Properties: 
      Code:
        ZipFile: |
          var response = require('cfn-response');
          exports.handler = function(event, context) {
            var responseData = {};
            response.send(event.Request, context, event.ResponseStatus, responseData, event.PhysicalResourceId);
          };
      # Environment:
      #   Variables:
      #     StateMachineArn: !Ref StateMachine
      Role: !GetAtt LambdaStartExecutionStepFunctionRole.Arn
      Runtime: nodejs14.x
      Handler: index.handler
      Timeout: 30


  LambdaMoveBackupFolderToRootEFS:
    Type: 'AWS::Lambda::Function' 
    Properties:
      Code:
        ZipFile: |
          exports.handler = async (event) => {
            const { execSync } = require('child_process');
            execSync('shopt -s dotglob \n mv aws-backup-restore_*/* .', {
              "cwd": process.env.mountPath});
            const response = {
              statusCode: 200,
              body: JSON.stringify('Hello from Lambda!'),
            };
            return response;
          };
      Environment:
        Variables:
          RestorePoint: !Ref RestorePoint
      Role: !GetAtt 
        - LambdaRole
        - Arn
      Runtime: nodejs14.x
      Handler: index.handler
      Timeout: 30
      VpcConfig:
        SecurityGroupIds:
          - !Ref LambdaSecurityGroup
        SubnetIds:
          - !Ref Subnet1

  AccessPoint:
    Type: 'AWS::EFS::AccessPoint'
    Properties:
      FileSystemId: !Ref RecoveredFileSystem
      PosixUser:
        Gid: 0
        Uid: 0
      RootDirectory:
        Path: /

  SecurityGroupEFS:
    Type: 'AWS::EC2::SecurityGroup'
    Properties:
      GroupDescription: Allow trafic from lambda
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 2049
          ToPort: 2049
          SourceSecurityGroupId: !Ref LambdaSecurityGroup
      VpcId: !Ref Vpc

  SecurityGroupEFS2:
    Type: 'AWS::EC2::SecurityGroup'
    Properties:
      GroupDescription: Allow trafic from lambda
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 2049
          ToPort: 2049
          SourceSecurityGroupId: !Ref LambdaSecurityGroup
      VpcId: !Ref Vpc    
  
  MountTarget:
    Type: 'AWS::EFS::MountTarget'
    Properties:
      FileSystemId: !Ref RecoveredFileSystem
      SecurityGroups:
        - !Ref SecurityGroupEFS
      SubnetId: !Ref Subnet1      

  MountTarget2:
    Type: 'AWS::EFS::MountTarget'
    Properties:
      FileSystemId: !Ref RecoveredFileSystem
      SecurityGroups:
        - !Ref SecurityGroupEFS2
      SubnetId: !Ref Subnet1         
# Outputs:
#   Efs:
#     Value: !If [IsEmpty, !Ref EmptyFileSystem, !Ref "AWS::NoValue"]
